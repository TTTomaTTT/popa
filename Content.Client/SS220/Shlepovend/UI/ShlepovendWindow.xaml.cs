// Â© SS220, An EULA/CLA with a hosting restriction, full text: https://raw.githubusercontent.com/SerbiaStrong-220/space-station-14/master/CLA.txt
using System.Linq;
using System.Threading;
using Content.Client.SS220.Discord;
using Content.Client.UserInterface.Controls;
using Content.Shared.CCVar;
using Content.Shared.SS220.CCVars;
using Content.Shared.SS220.Discord;
using Content.Shared.SS220.Shlepovend;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.Prototypes;
using Timer = Robust.Shared.Timing.Timer;

namespace Content.Client.SS220.Shlepovend.UI;

[GenerateTypedNameReferences]
public sealed partial class ShlepovendWindow : FancyWindow
{
    [Dependency] private readonly IEntityManager _entMan = default!;
    [Dependency] private readonly IPrototypeManager _prototype = default!;
    [Dependency] private readonly IConfigurationManager _conf = default!;
    [Dependency] private readonly IUriOpener _uri = default!;
    [Dependency] private readonly DiscordPlayerInfoManager _discordPlayerInfo = default!;

    private readonly ShlepovendSystem _shlepovendSys;

    public Action<(ProtoId<ShlepaRewardGroupPrototype>, EntProtoId)?>? OnPurchase;
    private List<ShlepovendGroup> _groups = new();
    private readonly CancellationTokenSource _timerCancelTokenSource = new();
    private string _boostyLink;
    private string _discordLink;
    private int? _lastTokens = null;

    public ShlepovendWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _shlepovendSys = _entMan.System<ShlepovendSystem>();

        AddAllGroups();
        UpdateContentData();

        _boostyLink = _conf.GetCVar(CCVars220.InfoLinksBoosty);
        BoostyButton.Visible = !string.IsNullOrEmpty(_boostyLink);
        BoostyButton.OnPressed += OnBoostyButtonPressed;
        _discordLink = _conf.GetCVar(CCVars.InfoLinksDiscord);
        DiscordButton.Visible = !string.IsNullOrEmpty(_discordLink);
        DiscordButton.OnPressed += OnDiscordButtonPressed;

        Timer.SpawnRepeating(500, UpdateContentData, _timerCancelTokenSource.Token);
    }

    private void OnBoostyButtonPressed(BaseButton.ButtonEventArgs args)
    {
        var uri = _conf.GetCVar(CCVars220.InfoLinksBoosty);
        if (!string.IsNullOrEmpty(uri))
            _uri.OpenUri(uri);
    }

    private void OnDiscordButtonPressed(BaseButton.ButtonEventArgs args)
    {
        var uri = _conf.GetCVar(CCVars.InfoLinksDiscord);
        if (!string.IsNullOrEmpty(uri))
            _uri.OpenUri(uri);
    }

    private void AddGroup(ShlepaRewardGroupPrototype groupProto)
    {
        var group = new ShlepovendGroup() { Group = groupProto };
        RewardGroupList.AddChild(group);
        _groups.Add(group);

        foreach (var button in group.Buttons)
        {
            button.OnPressed += OnItemPressed;
        }
    }

    private void OnItemPressed(BaseButton.ButtonEventArgs args)
    {
        if (args.Button is not ShlepovendItemButton button)
            return;

        if (button.ItemPrototypeId is null)
            return;

        if (!button.GroupProtoId.HasValue || !button.ItemPrototypeId.HasValue)
            return;

        OnPurchase?.Invoke((button.GroupProtoId.Value, button.ItemPrototypeId.Value));
    }

    private void AddAllGroups()
    {
        var groupList = new List<ShlepaRewardGroupPrototype>();

        foreach (var (_, groupProto) in _prototype.GetInstances<ShlepaRewardGroupPrototype>())
        {
            groupList.Add(groupProto);
        }

        /* no Convert.ToInt32 in sandbox, ya ebal System.Enum */
        var orderedGroupList = groupList.OrderBy(o => o.RequiredRole == null ? 0 : ((int) (object) o.RequiredRole));

        foreach (var group in orderedGroupList)
        {
            AddGroup(group);
        }
    }

    private void UpdateContentData()
    {
        int tokens = _shlepovendSys.Tokens;
        string? tierText = null;
        NotLinkedLabel.Visible = true;

        var playerTiers = _discordPlayerInfo.GetSponsorTier();
        if (playerTiers.Length > 0)
        {
            NotLinkedLabel.Visible = false;
            // Get highest available player's tier
            var highestAvailableTier = _shlepovendSys.GetHighestTier(playerTiers);
            tierText = highestAvailableTier?.Name;
        }

        TokensLabel.Text = Loc.GetString("shlepovend-tokens-left", ("tokens", tokens));

        if (tierText == null)
            tierText = Loc.GetString("shlepovend-subscription-level-unknown");
        SubscriptionLabel.Text = Loc.GetString("shlepovend-subscription-level", ("subscription", tierText));

        if (_lastTokens == null || _lastTokens != tokens)
        {
            _lastTokens = tokens;
            UpdateButtonAvailabiity();
        }
    }

    private void UpdateButtonAvailabiity()
    {
        var notAvailableText = Loc.GetString("shlepovend-not-available");
        var notEnoughText = Loc.GetString("shlepovend-not-enough");
        var playerTiers = _discordPlayerInfo.GetSponsorTier();

        foreach (var group in _groups)
        {
            // check if group is available to player
            var groupProto = group.Group;
            var isAvailable = false;
            if (groupProto != null)
            {
                foreach (var tier in playerTiers)
                {
                    if (groupProto.RequiredRole is SponsorTier &&
                    (int) tier >= (int) (SponsorTier) groupProto.RequiredRole)
                    {
                        isAvailable = true;
                        break;
                    }
                }
            }

            foreach (var button in group.Buttons)
            {
                var isEnough = button.Price <= _shlepovendSys.Tokens;
                button.AvailableLabel.Visible = !(isAvailable && isEnough);
                button.Disabled = !isAvailable || !isEnough;

                if (!isAvailable)
                    button.AvailableLabel.Text = notAvailableText;
                else if (!isEnough)
                    button.AvailableLabel.Text = notEnoughText;
            }
        }
    }

    public override void Close()
    {
        base.Close();
        _timerCancelTokenSource.Cancel();
    }

    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);

        if (disposing)
            _timerCancelTokenSource.Cancel();
    }
}
